<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="do.sibsutis.ru">

  <title>Тема 8. Конспект лекций</title>
	
	<link rel="icon" type="image/png" href="../lib/css/favicon.png">
  <!-- Bootstrap Core CSS -->
  <link href="../lib/css/bootstrap.css" rel="stylesheet">
	
  <!-- Custom CSS -->
  <link href="../lib/css/scrolling-nav.css" rel="stylesheet">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">
  <!-- Navigation -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
   <li class="hidden"> <a class="page-scroll" href="#page-top"></a> </li>
	 
	 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
   </button>
	 
   <a class="navbar-brand " href="../index.htm"> 
  <text class = "hidden-xs">Архитектура телекоммуникационных систем и сетей</text> 
  <text class = "visible-xs">Архитектура телекоммуникационных систем и сетей</text>
	 </a>
  </div>

  <!-- Collect the nav links, forms, and glyphicon glyphicon-list-alt content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
   
	 <!-- <ul class="nav navbar-nav">
		<li><a href="#"></a></li> 
   </ul> -->
	
   <ul class="nav navbar-nav navbar-right">
    <li class="dropdown">
		<button type="button" class="navbar-toggle dropdown-toggle hidden-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>	   
		<a class = "dropdown-toggle visible-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Материалы</a>
     <ul class="dropdown-menu">
    <li><a href="../index.htm">Аннотация курса</a></li>
      <li role="separator" class="divider"></li>
      <li><a href="lec_index.htm">Теория</a></li>
      <li><a href="c_work.htm">Курсовая работа</a></li>
      <li><a href="labs.htm">Лабораторные работы</a></li>
     
      <li role="separator" class="divider"></li>
    
      <li><a href="lit.htm">Литература</a></li>
      <!--li><a href="q.htm">Вопросы для самопроверки</a></li-->			
     </ul>
 </li>
 </ul>
  </div><!-- /.navbar-collapse -->
 </div><!-- /.container-fluid -->
</nav>


  <div id="intro" class="section content-section ">
    <div class="container">
       <div class="row">
        <div class="col-lg-12">	


<!-- содержание -->	
<div class="page-header">				
<h3><a href="#">Тема 8. Эффективное (статистическое) 
    кодирование</a></h3>


</div>
<!--начало-->
         <p> Эффективное кодирование
          – это процедуры направленные на устранение избыточности.  </P>
        <p> Основная задача эффективного
          кодирования – обеспечить, в среднем, минимальное число двоичных элементов
          на передачу сообщения источника. В этом случае, при заданной скорости
          модуляции обеспечивается передача максимального числа сообщений, а значит
          максимальная скорости передачи информации. </P>
        <p> Пусть имеется источник
          дискретных сообщений, алфавит которого <IMG SRC="images/Image227.gif" WIDTH=21 HEIGHT=20 align="absmiddle">. </P>
        <p> При кодировании сообщений
          данного источника двоичным, равномерным кодом, потребуется <IMG SRC="images/Image228.gif" WIDTH=112 HEIGHT=30 align="absmiddle">
          двоичных элементов на кодирование каждого сообщения. </P>
        <p> Если вероятности <IMG SRC="images/Image229.gif" WIDTH=49 HEIGHT=29 align="absmiddle">
          появления всех сообщений источника равны, то энтропия источника (или
          среднее количество информации в одном сообщении) максимальна и равна
          <IMG SRC="images/Image230.gif" WIDTH=150 HEIGHT=29 align="absmiddle">. </P>
        <p> В данном случае каждое
          сообщение источника имеет информационную емкость <IMG SRC="images/Image231.gif" WIDTH=109 HEIGHT=30 align="absmiddle">
          бит, и очевидно, что для его кодирования (перевозки) требуется двоичная
          комбинация не менее <IMG SRC="images/Image232.gif" WIDTH=30 HEIGHT=30 align="absmiddle"> элементов.
          Каждый двоичный элемент, в этом случае, будет переносить 1 бит информации. </P>
        <p> Если при том же объеме
          алфавита сообщения не равновероятны, то, как известно, энтропия источника
          будет меньше </P>
        <p> <IMG SRC="images/Image233.gif" WIDTH=350 HEIGHT=53>. </P>
        <p> Если и в этом случае использовать
          для перевозки сообщения <IMG SRC="images/Image234.gif" WIDTH=30 HEIGHT=30 align="absbottom">-разрядные
          кодовые комбинации, то на каждый двоичный элемент кодовой комбинации
          будет приходиться меньше чем 1 бит. </P>
        <p> Появляется избыточность,
          которая может быть определена по следующей формуле </P>
        <p> <IMG SRC="images/Image235.gif" WIDTH=466 HEIGHT=64>. </P>
        <p></P>
        <p> Среднее количество информации,
          приходящееся на один двоичный элемент комбинации при кодировании равномерным
          кодом </P>
        <p> <IMG SRC="images/Image236.gif" WIDTH=172 HEIGHT=64>. </P>
        <p> <u><b><i>Пример </i></b></u> </P>
        <p> Для кодирования 32 букв
          русского алфавита, при условии равновероятности, нужна 5 разрядная кодовая
          комбинация. При учете ВСЕХ статистических связей реальная энтропия составляет
          около 1,5 бит на букву. Нетрудно показать, что избыточность в данном
          случае составит  </P>
        <p> <IMG SRC="images/Image237.gif" WIDTH=213 HEIGHT=58>,
           </P>
        <p></P>
        <p> Если средняя загрузка единичного
          элемента так мала, встает вопрос, нельзя ли уменьшить среднее количество
          элементов необходимых для переноса одного сообщения и как наиболее эффективно
          это сделать? </P>
        <p> Для решения этой задачи 
          используются неравномерные коды. </P>
        <p> При этом, для передачи
          сообщения, содержащего большее количество информации, выбирают более
          длинную кодовую комбинацию, а для передачи сообщения с малым объемом
          информации используют короткие кодовые комбинации. </P>
        <p> Учитывая, что объем информации,
          содержащейся в сообщении, определяется вероятностью появления </P>
        <p> <IMG SRC="images/Image238.gif" WIDTH=244 HEIGHT=58 align="absmiddle">,
          можно перефразировать данное высказывание. </P>
        <p> Для сообщения, имеющего
          высокую вероятность появления, выбирается более короткая комбинация
          и наоборот, редко встречающееся сообщение кодируется длинной комбинацией. </P>
        <p> Т.о. на одно сообщение
          будет затрачено в среднем меньшее единичных элементов <IMG SRC="images/Image239.gif" WIDTH=178 HEIGHT=53 align="absmiddle">,
          чем при равномерном. </P>
        <p> Если скорость телеграфирования
          постоянна, то на передачу одного сообщения будет затрачено в среднем
          меньше времени </P>
        <p> <IMG SRC="images/Image240.gif" WIDTH=145 HEIGHT=53> </P>
        <p> А значит, при той же скорости
          телеграфирования будет передаваться большее число сообщений в единицу
          времени, чем при равномерном кодировании, т.е. обеспечивается большая
          скорость передачи информации. </P>
        <p> Каково же в среднем минимальное 
          количество единичных элементов требуется для передачи сообщений данного 
          источника? </P>
        <p> Ответ на этот вопрос дал 
          Шеннон. </P>
        <p> Шеннон показал, что </P>
        <p> 1. Нельзя закодировать
          сообщение двоичным кодом так, что бы средняя длина кодового слова <IMG SRC="images/Image241.gif" WIDTH=12 HEIGHT=26 align="absmiddle">
          была численно меньше величины энтропии источника сообщений <IMG SRC="images/Image242.gif" WIDTH=74 HEIGHT=30 align="absmiddle">.
          <IMG SRC="images/Image243.gif" WIDTH=104 HEIGHT=33 align="absmiddle">, где <IMG SRC="images/Image244.gif" WIDTH=125 HEIGHT=53 align="absmiddle">. </P>
        <p> 2. Существует способ кодирования,
          при котором средняя длина кодового слова немногим отличается от энтропии
          источника  </P>
        <p> <IMG SRC="images/Image245.gif" WIDTH=226 HEIGHT=33> </P>
        <p> Остается выбрать подходящий
          способ кодирования. </P>
        <p> Эффективность применения
          оптимальных неравномерных кодов может быть оценена: </P>
        <OL>
          <LI> Коэффициентом статистического сжатия,
            который характеризует уменьшение числа двоичных элементов на сообщение,
            при применении методов эффективного кодирования в сравнении с равномерным
            <IMG SRC="images/Image204.gif" WIDTH=12 HEIGHT=22><IMG SRC="images/Image246.gif" WIDTH=77 HEIGHT=44 align="absmiddle">. </LI>  Учитывая, что <IMG SRC="images/Image247.gif" WIDTH=196 HEIGHT=30 align="absmiddle">,
            можно записать <IMG SRC="images/Image248.gif" WIDTH=126 HEIGHT=53 align="absmiddle">. 
          <p> Ксс лежит в пределах
            от 1 - при равномерном коде до </P>
          <p>  <IMG SRC="images/Image249.gif" WIDTH=158 HEIGHT=61 align="absmiddle">,
            при наилучшем способе кодирования. </P>
          <LI> Коэффициент относительной эффективности </LI>
        </OL>
        <p> <IMG SRC="images/Image250.gif" WIDTH=134 HEIGHT=56 align="absmiddle">
          - позволяет сравнить эффективность применения различных методов эффективного
          кодирования.  </P>
        <p> В неравномерных кодах возникает
          проблема разделения кодовых комбинаций. Решение данной проблемы обеспечивается
          применением префиксных кодов. </P>
        <p> <I><B>Префиксным</b></i>
          называют код, для которого никакое более короткое слово не является
          началом другого более длинного слова кода. Префиксные коды всегда однозначно
          декодируемы.  </P>
        <p> Веедем понятие кодового
          дерева для множества кодовых слов. </P>
        <p> Наглядное графическое изображение
          множества кодовых слов можно получить, установив соответствие между
          сообщениями и концевыми узлами двоичного дерева. Пример двоичного кодового
          дерева изображен на рисунке. 1.  </P>
        <p> <b><img src="images/Image251.gif" width="419" height="239"></b> </P>
        <p> <B>Рисунок 1</b>. Пример
          двоичного кодового дерева </P>
        <p> Две ветви, идущие от корня
          дерева к узлам первого порядка, соответствуют выбору между “0” и “1”
          в качестве первого символа кодового слова: левая ветвь соответствует
          “0”, а правая – “1”. Две ветви, идущие из узлов первого порядка, соответствуют
          второму символу кодовых слов, левая означает “0”, а правая – “1” и т.
          д. Ясно, что последовательность символов каждого кодового слова определяет
          необходимые правила продвижения от корня дерева до концевого узла, соответствующего
          рассматриваемому сообщению.  </P>
        <p> Формально кодовые слова
          могут быть приписаны также промежуточным узлам. Например, промежуточному
          узлу второго порядка на рис.1 можно приписать кодовое слово 11, которое
          соответствует первым двум символам кодовых слов, соответствующих концевым
          узлам, порождаемых этим узлом. Однако кодовые слова, соответствующие
          промежуточным узлам, не могут быть использованы для представления сообщений,
          так как в этом случае нарушается требование префиксности кода.  </P>
        <p> Требование, чтобы только
          концевые узлы сопоставлялись сообщениям, эквивалентно условию, чтобы
          ни одно из кодовых слов не совпало с началом (префиксом) более длинного
          кодового слова. </P>
        <p> Любой код, кодовые слова
          которого соответствуют различным концевым вершинам некоторого двоичного
          кодового дерева, является префиксным, т. е. однозначно декодируемым.
           </P>
        <p> <b>Метод Хаффмена </b> </P>
        <p> Одним из часто используемых
          методов эффективного кодирования является так называемый код Хаффмена.
           </P>
        <p> Пусть сообщения входного
          алфавита <IMG SRC="images/Image252.gif" WIDTH=146 HEIGHT=29 align="absmiddle"> имеют соответственно
          вероятности их появления <IMG SRC="images/Image253.gif" WIDTH=93 HEIGHT=29 align="absbottom"><I>.
          </i> </P>
        <p> Тогда алгоритм кодирования
          Хаффмена состоит в следующем:  </P>
        <p> 1. Сообщения располагаются
          в столбец в порядке убывания вероятности их появления. </P>
        <p> 2. Два самых маловероятных
          сообщения объединяем в одно сообщение <IMG SRC="images/Image254.gif" WIDTH=14 HEIGHT=22 align="absmiddle">,<I>
          </I>которое имеет вероятность, равную сумме вероятностей сообщений <IMG SRC="images/Image255.gif" WIDTH=68 HEIGHT=28 align="absmiddle"><I>,
          </I>т. е. <IMG SRC="images/Image256.gif" WIDTH=85 HEIGHT=28 align="absmiddle">. В результате
          получим сообщения <IMG SRC="images/Image257.gif" WIDTH=132 HEIGHT=28 align="absmiddle"><I>, </I>вероятности
          которых <IMG SRC="images/Image258.gif" WIDTH=209 HEIGHT=28><I>. </i> </P>
        <p> 3. Повторяем шаги 1 и 2
          до тех пор, пока не получим единственное сообщение, вероятность которого
          равна 1. </P>
        <p> 4. Проводя линии, объединяющие
          сообщения и образующие последовательные подмножества, получаем дерево,
          в котором отдельные сообщения являются концевыми узлами. Соответствующие
          им кодовые слова можно определить, приписывая правым ветвям объединения
          символ “1”, а левым - “0”. <I>Впрочем, понятия “правые” и “левые” ветви
          в данном случае относительны.</i> </P>
        <p></P>
        <p><img src="images/Image259.gif" width="515" height="450"></P>
        <DIR> <DIR>
        <p> На основании полученной
          таблицы можно построить кодовое дерево </P>
        </DIR></DIR>
        <p> <a href="images/Image260.gif" target="_blank">Рисунок "Кодовое дерево"
          </a>  </P>
        <p> Так как в процессе кодирования
          сообщениям сопоставляются только концевые узлы, полученный код является
          префиксным и всегда однозначно декодируем. </P>
        <p> При равномерных кодах одиночная 
          ошибка в кодовой комбинации приводит к неправильному декодированию только 
          этой комбинации. Одним из серьёзных недостатков префиксных кодов является 
          появление трека ошибок, т.е. одиночная ошибка в кодовой комбинации, 
          при определенных обстоятельствах, способна привести к неправильному 
          декодированию не только данной, но и нескольких последующих кодовых 
          комбинаций. </P>
        <P> <b><i>Пример на однозначность декодирования 
          и трек ошибок </i></b> </P>
        <P> Пусть передавалась следующая последовательность </P>
        <P> <U>1 0</u> <U>0 1</U> <U>1 1 0</U> <U>0
          0 1</u> </P>
        <P>  a b c d </P>
        <P> При возникновении ошибки в первом двоичном
          элементе, получим </P>
        <P> <U>0 0 0 1</u> <U>1 1 0</U> <U>0 0 1</u> </P>
        <P>  g c d </P>
        <p>  Т.О. ошибка в одном разряде
          комбинации первого символа привела к неправильному декодированию двух
          символов. (Трек ошибок). </P>
        <p> Контрольные вопросы по 
          теме: </P>
        <OL>
          <LI> Назначение и цели эффективного кодирования. </LI><LI> Поясните за счет чего, обеспечивается
            достижение сжатия при эффективном кодировании. </LI><LI> Чем определяется минимальная средняя
            длина кодовой комбинация при применении эффективном кодировании. </LI><LI> Какие проблемы возникают при разделении
            неравномерных кодовых комбинаций. </LI><LI> Что такое префиксные коды. </LI><LI>В чем заключается алгоритм Хаффмана. </LI><LI> Что такое трек ошибок, и каковы причины
            его возникновения.  </LI>
        </OL>
       
<br><br>
<!--конец-->
      
				

				</div>
			</div>
			
      </div>
    </div>
  </div>
	
	<!--Меню навигации по Темам -->	
	<div aria-label="..." class = "nav-menu">
	 <ul class="pager background-transition-slow">
		 <li title="Наверх" style = "margin-right:15px;	"><a class = "glyphicon glyphicon-menu-up page-scroll" href="#page-top"></a></li>
		 <li title="К предыдущей лекции"><a class = "glyphicon glyphicon-menu-left page-scroll" href="t7.htm"></a></li>
		 <li title="В содержание"><a class = "glyphicon glyphicon-list-alt" href="lec_index.htm"></a></li>
		 <li title="К следующей лекции"><a class = "glyphicon glyphicon-menu-right page-scroll" href="t9.htm"></a></li>
	 </ul>
	</div>
	<!---->
	
	</div>
  <!-- jQuery -->
  <script src="../lib/js/jquery.js"></script>

  <!-- Bootstrap Core JavaScript -->
  <script src="../lib/js/bootstrap.min.js"></script>

  <!-- Scrolling Nav JavaScript -->
  <script src="../lib/js/jquery.easing.min.js"></script>
  <script src="../lib/js/scrolling-nav.js"></script>

</body>

</html>
