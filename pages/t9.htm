<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="do.sibsutis.ru">

  <title>Тема 9. Конспект лекций</title>
	
	<link rel="icon" type="image/png" href="../lib/css/favicon.png">
  <!-- Bootstrap Core CSS -->
  <link href="../lib/css/bootstrap.css" rel="stylesheet">
	
  <!-- Custom CSS -->
  <link href="../lib/css/scrolling-nav.css" rel="stylesheet">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">
  <!-- Navigation -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
   <li class="hidden"> <a class="page-scroll" href="#page-top"></a> </li>
	 
	 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
   </button>
	 
   <a class="navbar-brand " href="../index.htm"> 
  <text class = "hidden-xs">Архитектура телекоммуникационных систем и сетей</text> 
  <text class = "visible-xs">Архитектура телекоммуникационных систем и сетей</text>
	 </a>
  </div>

  <!-- Collect the nav links, forms, and glyphicon glyphicon-list-alt content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
   
	 <!-- <ul class="nav navbar-nav">
		<li><a href="#"></a></li> 
   </ul> -->
	
   <ul class="nav navbar-nav navbar-right">
    <li class="dropdown">
		<button type="button" class="navbar-toggle dropdown-toggle hidden-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>	   
		<a class = "dropdown-toggle visible-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Материалы</a>
     <ul class="dropdown-menu">
    <li><a href="../index.htm">Аннотация курса</a></li>
      <li role="separator" class="divider"></li>
      <li><a href="lec_index.htm">Теория</a></li>
      <li><a href="c_work.htm">Курсовая работа</a></li>
      <li><a href="labs.htm">Лабораторные работы</a></li>
     
      <li role="separator" class="divider"></li>
    
      <li><a href="lit.htm">Литература</a></li>
      <!--li><a href="q.htm">Вопросы для самопроверки</a></li-->			
     </ul>
 </li>
 </ul>
  </div><!-- /.navbar-collapse -->
 </div><!-- /.container-fluid -->
</nav>


  <div id="intro" class="section content-section ">
    <div class="container">
       <div class="row">
        <div class="col-lg-12">	


<!-- содержание -->	
<div class="page-header">				
<h3><a href="#">Тема 9. Защита от ошибок в системах 
    связи</a></h3>
 <P><a href="#1" class=punkt>9.1 Понятие о корректирующих 
    кодах</a> 
    </P>
  <P><a href="#2" class=punkt>9.2 Циклические коды</a></P>
  <P><a href="#3" class=punkt>9.3 Выбор образующего полинома 
    циклического кода</a></P>
  

</div>
<!--начало-->

 <p> От СПДС обычно требуется
          не только передавать сообщения с заданной скоростью передачи информации,
          но и обеспечивать при этом требуемую достоверность. </P>
        <p> Получив сообщение, пользователь
          должен быть с высокой степенью уверен, что отправлялось именно это сообщение. </P>
        <p> Помехи, действующие в канале,
          как известно, приводят к возникновению ошибок. Исходная вероятность
          ошибки в каналах связи обычно не позволяет достичь высокой степени достоверности
          без применения дополнительных мероприятий. К таким мероприятиям, обеспечивающим
          защиту от ошибок, относят применения корректирующих кодов. </P>
        <p> В общей структурной схеме
          СПДС задачу защиты от ошибок выполняет кодер и декодер канала, который
          иногда называют УЗО. </P>
        <P></P>
         <a name=1 class="anchor"></a><h3>9.1 
          Понятие о корректирующих кодах</h3>
        <p></P>
        <p> Пусть имеется источник
          сообщений с объемом алфавита К. </P>
        <p> Поставим в соответствие
          каждому сообщению n - элементную двоичную последовательность. Всего
          последовательностей из n - элементов может быть <IMG SRC="images/Image261.gif" WIDTH=54 HEIGHT=25 align="absmiddle">. </P>
        <p> Если <IMG SRC="images/Image262.gif" WIDTH=52 HEIGHT=24 align="texttop">,
          то все последовательности (или кодовые комбинации) будут использоваться
          для кодирования сообщений, т.е. будут <B><I>разрешенными.</i></b> </P>
        <p> Полученный таким образом
          код называется <B><I>простым</i></B>, он не способен обнаруживать и
          исправлять ошибки. </P>
        <p> Для того, что бы код мог
          обнаруживать и исправлять ошибки необходимо выполнение условия <IMG SRC="images/Image263.gif" WIDTH=52 HEIGHT=24 align="absmiddle">,
          при этом неиспользуемые для передачи комбинации (N<SUB>0</SUB>-K) называют
          <B><I>запрещенными</i></B>. </P>
        <p> Появление ошибки в кодовой 
          комбинации будет обнаружено, если передаваемая разрешенная комбинация 
          перейдет в одну из запрещенных. </P>
        <p> <B>Расстояние Хемминга</b>
          – характеризует степень различия кодовых комбинаций и определяется числом
          несовпадающих в них разрядов. </P>
        <p> Перебрав все возможные 
          пары разрешенных комбинаций рассматриваемого кода можно найти минимальное 
          расстояние Хемминга d<SUB>0</SUB>. </P>
        <p> Минимальное расстояние
          d<SUB>0</SUB> - называется <B><I>кодовым расстоянием</i></B>  </P>
        <p> Кодовое расстояние определяет
          способность кода обнаруживать и исправлять ошибки. </P>
        <p> У простого кода d<SUB>0</SUB>=1 
          – он не обнаруживает и не исправляет ошибки. Так как любая ошибка переводит 
          одну разрешенную комбинацию в другую. </P>
        <p> В общем случае справедливы
          следующие соотношения </P>
        <p> <IMG SRC="images/Image264.gif" WIDTH=74 HEIGHT=24 align="absmiddle"> 
          – для обнаруживающей способности &#9;&#9; </P>
        <p></P>
        <p> <SUB><IMG SRC="images/Image265.gif" WIDTH=218 HEIGHT=82 align="absmiddle"></sub>
          – для исправляющей способности<SUB>&#9;</sub> </P>
        <p></P>
        <P> <b><u>Линейные коды.</u></b> </P>
        <p> Двоичный блочный код является 
          линейным если сумма по модулю 2 двух кодовых слов является также кодовым 
          словом. </P>
        <p> Линейные коды также называют
          групповыми. </P>
        <p> <b><i>Введем понятия группы.</i></b> </P>
        <p> Множество элементов с определенной
          на нем групповой операцией называется группой, если выполняется следующие
          условия: </P>
        <p> 1. Замкнутость g<SUB>i 
          &#197;<img src="images/xor.gif" width="17" height="17"> </SUB>g <SUB>j</SUB>= 
          g<SUB>k</SUB> <img src="images/have.gif" width="13" height="14">G в 
          результате операции с двумя элементами группы получается третий, так 
          же принадлежащий этой группе. </P>
        <p> 2. Ассоциативность (сочетательность) 
          (g<SUB>i<img src="images/xor.gif" width="17" height="17"> </SUB>g<SUB>j</SUB>)<SUB><img src="images/xor.gif" width="17" height="17"></SUB> 
          g<SUB>k</SUB> = g<SUB>i<img src="images/xor.gif" width="17" height="17"> 
          </SUB> (g<SUB>j</SUB> <SUB><img src="images/xor.gif" width="17" height="17"></SUB> 
          g<SUB>k</SUB>) </P>
        <p> 3. Наличие нейтрального 
          элемента g<SUB>j <img src="images/xor.gif" width="17" height="17"> </SUB> 
          e = g<SUB>j</sub> </P>
        <p> 4. Наличие обратного элемента. 
          g<SUB>i <img src="images/xor.gif" width="17" height="17"> </SUB> (g<SUB>i</SUB>)<SUP>-1</SUP>= 
          e </P>
        <p> Если выполняется условие 
          g<SUB>i <img src="images/xor.gif" width="17" height="17"> </SUB> g<SUB>j 
          </SUB>= g<SUB>j <img src="images/xor.gif" width="17" height="17"> </SUB> 
          g<SUB>i</SUB>, то группа называется коммутативной. </P>
        <p></P>
        <p> Множество кодовых комбинаций
          n-элементного кода является замкнутой группой с заданной групповой операцией
          сложение по модулю 2. </P>
        <p> <B>Поэтому</b> используя 
          свойство замкнутости относительно операции <SUB><img src="images/xor.gif" width="17" height="17"></SUB> 
          2, множество всех элементов можно задать не перечислением всех элементов, 
          а производящей матрицей.  </P>
        <p> Все остальные элементы,
          кроме 0, могут быть получены путем сложения по модулю 2 строк производящей
          матрицы в различных сочетаниях.  </P>
        <p> В общем случае строки производящей
          матрицы могут быть любыми линейно независимыми, но проще и удобнее брать
          в качестве производящей матрицы – <B><I>единичную</i></B>. </P>
        <p> <IMG SRC="images/Image266.gif" WIDTH=92 HEIGHT=96> </P>
         <a name=2 class="anchor"></a><h3>9.2 
          ЦИКЛИЧЕСКИЕ КОДЫ</h3>
          <p> Широкое распространение
          на практике получил класс линейных кодов, которые называются циклическими.
          Данное название происходит от основного свойства этих кодов:  </P>
        <p> если некоторая кодовая
          комбинация принадлежит циклическому коду, то комбинация полученная циклической
          перестановкой исходной комбинации (циклическим сдвигом), также принадлежит
          данному коду. </P>
        <P> <IMG SRC="images/Image267.gif" WIDTH=282 HEIGHT=25>. </P>
        <p> Вторым свойством всех разрешенных
          комбинаций циклических кодов является их делимость без остатка на некоторый
          выбранный полином, называемый производящим. </P>
        <p> Синдромом ошибки в этих
          кодах является наличие остатка от деления принятой кодовой комбинации
          на производящий полином. </P>
        <p> Эти свойства используются
          при построении кодов, кодирующих и декодирующих устройств, а также при
          обнаружении и исправлении ошибок. </P>
        <P> <b><u>Представление кодовой
          комбинации в виде многочлена.</u></b> </P>
        <p></P>
        <p> Описание циклических кодов
          и их построение удобно проводить с помощью многочленов (или полиномов). </P>
        <p> В теории циклических кодов
          кодовые комбинации обычно представляются в виде полинома. Так, n-элементную
          кодовую комбинацию можно описать полиномом (n-1) степени, в виде </P>
        <p> <IMG SRC="images/Image268.gif" WIDTH=330 HEIGHT=29>. </P>
        <p> где <IMG SRC="images/Image269.gif" WIDTH=20 HEIGHT=29 align="absmiddle">={0,1},
          причем <IMG SRC="images/Image270.gif" WIDTH=20 HEIGHT=29 align="absmiddle">= 0 соответствуют
          нулевым элементам комбинации, а <IMG SRC="images/Image271.gif" WIDTH=20 HEIGHT=29 align="absmiddle">=
          1 - ненулевым.  </P>
        <p> Запишем полиномы для конкретных
          4-элементных комбинаций </P>
        <P> <IMG SRC="images/Image272.gif" WIDTH=177 HEIGHT=24> </P>
        <P> <IMG SRC="images/Image273.gif" WIDTH=157 HEIGHT=24> </P>
        <P> <b><u>Действия над многочленами.</u></b> </P>
        <p> При формировании комбинаций
          циклического кода часто используют операции сложения многочленов и деления
          одного многочлена на другой. Так,  </P>
        <p> <IMG SRC="images/Image274.gif" WIDTH=428 HEIGHT=30>, </P>
        <p> поскольку <IMG SRC="images/Image275.gif" WIDTH=189 HEIGHT=30 align="absmiddle">. </P>
        <p> Следует отметить, что действия
          над коэффициентами полинома (сложение и умножение) производятся по модулю
          2. </P>
        <p> Рассмотрим операцию деления
          на следующем примере: </P>
        <p> <IMG SRC="images/Image276.gif" WIDTH=193 HEIGHT=139> </P>
        <p> Деление выполняется, как
          обычно, только вычитание заменяется суммированием по модулю два. </P>
        <p> Отметим, что запись кодовой
          комбинации в виде многочлена, не всегда определяет длину кодовой комбинации.
          Например, при n = 5, многочлену <IMG SRC="images/Image277.gif" WIDTH=44 HEIGHT=21 align="absmiddle">
          соответствует кодовая комбинация 00011. </P>
        <P> <b><u>Алгоритм получения
          разрешенной кодовой комбинации циклического кода из комбинации простого
          кода</u></b> </P>
        <p> Пусть задан полином <IMG SRC="images/Image278.gif" WIDTH=262 HEIGHT=30 align="absmiddle">,
          определяющий корректирующую способность кода и число проверочных разрядов
          r, а также исходная комбинация простого k-элементного кода в виде многочлена
          <IMG SRC="images/Image279.gif" WIDTH=49 HEIGHT=24 align="absmiddle">.  </P>
        <p> Требуется определить разрешенную
          кодовую комбинацию циклического кода (n, k). </P>
        <OL>
          <P> 
          <LI> Умножаем многочлен исходной кодовой 
            комбинации на <IMG SRC="images/Image280.gif" WIDTH=21 HEIGHT=24 align="absmiddle"><br>
             </LI>
          <P> <IMG SRC="images/Image281.gif" WIDTH=92 HEIGHT=32> </P>
          <LI> Определяем проверочные разряды, дополняющие 
            исходную информационную комбинацию до разрешенной, как остаток от 
            деления полученного в предыдущем пункте произведения на образующий 
            полином </LI>
           <P> <IMG SRC="images/Image282.gif" WIDTH=166 HEIGHT=60> </P>
          <LI> Окончательно разрешенная кодовая комбинация 
            циклического кода определится так </LI>
          </OL>
        <P> <IMG SRC="images/Image283.gif" WIDTH=226 HEIGHT=32> </P>
        <p> Для обнаружения ошибок
          в принятой кодовой комбинации достаточно поделить ее на производящий
          полином. Если принятая комбинация - разрешенная, то остаток от деления
          будет нулевым. Ненулевой остаток свидетельствует о том, что принятая
          комбинация содержит ошибки. По виду остатка (синдрома) можно в некоторых
          случаях также сделать вывод о характере ошибки, ее местоположении и
          исправить ошибку. </P>
        <p></P>
        <P> <b><u>Формирование базиса
          (производящей матрицы) циклического кода</u></b> </P>
        <P> Формирование базиса циклического кода возможно
          как минимум двумя путями. </P>
        <P> <b>Вариант первый.</b> </P>
        <OL>
          <LI> Составить единичную матрицу для простого
            исходного кода. </LI>
          <LI> Определить для каждой кодовой комбинации
            исходного кода группу проверочных элементов и дописать их в соответствующие
            строки матрицы. </LI>
        </OL>
        <P> <IMG SRC="images/Image284.gif" WIDTH=160 HEIGHT=159> </P>
        <p> Полученная матрица и будет
          базисом циклического кода. Причем, в данном случае, разрешенные комбинации
          заведомо разделимы (т.е. информационные и проверочные элементы однозначно
          определены). </P>
        <P> <b>Вариант второй.</b> </P>
        <OL>
          <LI> Дописать слева от КК, соответствующей
            образующему полиному циклического кода нули так, чтобы длина разрешенной
            кодовой комбинации равнялась n. </LI>
          <LI> Получить остальные разрешенные кодовые
            КК базиса, используя циклический сдвиг исходной. (В базисе должно
            быть k – строк) </LI>
        </OL>
        <DIR> <DIR>
        <p> В данном случае код будет
          неразделимым. </P>
        </DIR></DIR>
        <p> Получив базис ЦК, можно
          получить все разрешенные комбинации, проводя сложение по модулю 2 кодовых
          комбинаций базиса в различных сочетаниях и плюс НУЛЕВАЯ. </P>
        <p> Циклические коды достаточно
          просты в реализации, обладают высокой корректирующей способностью (способностью
          исправлять и обнаруживать ошибки) и поэтому рекомендованы МСЭ-Т для
          применения в аппаратуре ПД. Согласно рекомендации V.41 в системах ПД
          с ОС рекомендуется применять код с производящим полиномом  </P>
        <P> <IMG SRC="images/Image285.gif" WIDTH=230 HEIGHT=36> </P>
        <P> <b><u>Построение кодера
          циклического кода</u></b> </P>
        <p> Рассмотрим код (9,5) образованный
          полиномом </P>
        <p> <IMG SRC="images/Image286.gif" WIDTH=156 HEIGHT=34>. </P>
        <p> Разрешенная комбинация
          циклического кода <IMG SRC="images/Image287.gif" WIDTH=49 HEIGHT=28 align="absmiddle"> образуется
          из комбинации простого (исходного) кода путем умножения ее на <IMG SRC="images/Image288.gif" WIDTH=25 HEIGHT=26 align="absmiddle">
          и прибавления остатка R(x) от деления <IMG SRC="images/Image289.gif" WIDTH=69 HEIGHT=30 align="absmiddle">на
          образующий полином<IMG SRC="images/Image290.gif" WIDTH=54 HEIGHT=32 align="absmiddle">. </P>
        <OL>
          <LI> Умножение полинома на одночлен <IMG SRC="images/Image291.gif" WIDTH=24 HEIGHT=26 align="absmiddle">
             
        </OL>
          эквивалентно добавлению к двоичной последовательности 
        соответствующей G(x) , r - нулей справа.   
        <p> Пусть <IMG SRC="images/Image292.gif" WIDTH=226 HEIGHT=30 align="absmiddle"> </P>
        <p> тогда <IMG SRC="images/Image293.gif" WIDTH=476 HEIGHT=30 align="absmiddle"> </P>
        <p> Для реализации операции
          добавления нулей используется r-разрядный регистр задержки. </P>
        <OL START=2>
         <LI> Рассмотрим более подробно операцию деления:
             </LI>
          <p></P>
        </OL>
        <DIR> 
        <P><img src="images/Image294.gif" width="229" height="300"></P>
        </DIR>
        <p> Как видим из примера, процедура
          деления одного двоичного числа на другое сводится к последовательному
          сложению по <B><I>mod2</i></B> делителя [10011] с соответствующими членами
          делимого [10101], затем с двоичным числом, полученным в результате первого
          сложения, далее с результатом второго сложения и т.д., пока число членов
          результирующего двоичного числа не станет меньше числа членов делителя. </P>
        <p> Это двоичное число и будет
          остатком <IMG SRC="images/Image295.gif" WIDTH=48 HEIGHT=28 align="absmiddle">.  </P>
        <p> <b><u>Построение формирователя
          остатка циклического кода</u></b> </P>
        <p> Структура устройства осуществляющего
          деление на полином полностью определяется видом этого полинома. Существуют
          правила позволяющие провести построение однозначно. </P>
        <p> Сформулируем правила построения
          ФПГ. </P>
        <OL>
          <LI> Число ячеек памяти равно степени образующего
            полинома r. </LI>
          <LI> Число сумматоров на единицу меньше веса
            кодирующей комбинации образующего полинома. </LI>
          <LI> Место установки сумматоров определяется
            видом образующего полинома.<IMG SRC="images/Image296.gif" WIDTH=12 HEIGHT=22>
             
        </OL>
         &#9;
         
        <p><img src="images/Image297.gif" width="500" height="162"></P>
        <p> Сумматоры ставят после
          каждой ячейки памяти, (начиная с нулевой) для которой существует НЕнулевой
          член полинома. Не ставят после ячейки для которой в полиноме нет соответствующего
          члена и после ячейки старшего разряда. </P>
        <p> 4. В цепь обратной связи
          необходимо поставить ключ, обеспечивающий правильный ввод исходных элементов
          и вывод результатов деления. </P>
        <DIR>
        <P> <b><u>Структурная схема
          кодера циклического кода (9,5)</u></b> </P>
        <p></P>
        </DIR>
        <p> Полная структурная схема
          кодера приведена на следующем рисунке. Она содержит регистр задержки
          и рассмотренный выше формирователь проверочной группы. </P>
        <p><img src="images/Image298.gif" width="567" height="290"></P>
        <p> Рассмотрим работу этой
          схемы </P>
        <p> 1. На первом этапе К<SUB>1</SUB>–
          замкнут К<SUB>2 </SUB>– разомкнут. Идет одновременное заполнение регистров
          задержки и сдвига информ. элементами (старший вперед!) и через 4 такта
          старший разряд в ячейке №4 </P>
        <p> 2. Во время пятого такта
          К<SUB>2 </SUB>– замыкается а К<SUB>1</SUB> – размыкается с этого момента
          в ФПГ формируется остаток. Одновременно из РЗ на выход выталкивается
          задержание информационные разряды. </P>
        <p> За 5 тактов (с 5 по 9 включительно)
          в линию уйдут все 5-информационных элемента. К этому времени в ФПГ сформируется
          остаток </P>
        <p> 3. К<SUB>2</SUB> – размыкается,
          К<SUB>1</SUB> – замыкается и в след за информационными в линию уйдут
          элементы проверочной группы. </P>
        <p> 4. Одновременно идет заполнение
          регистров новой комбинацией. </P>
        <P> <u>Второй вариант построения
          кодера ЦК.</u> </P>
        <p> Рассмотренный выше кодер
          очень наглядно отражает процесс деления двоичных чисел. Однако можно
          построить кодер содержащий меньшее число элементов т.е. более экономичный. </P>
        <p> Устройство деления на производящий
          полином <IMG SRC="images/Image299.gif" WIDTH=152 HEIGHT=29 align="absmiddle"> можно реализовать
          в следующем виде: </P>
        <p><img src="images/Image300.gif" width="440" height="115"></P>
        <p> За пять тактов в ячейках
          будет сформирован такой же остаток от деления, что и в рассмотренном
          выше Формирователе проверочной группы. (ФПГ). </P>
        <p> За эти же 5 тактов информационные
          разряды, выданные сразу на модулятор.  </P>
        <p> Далее в след за информационными
          уходят проверочные из ячеек устройств деления. </P>
        <p> Но важно отключить обратную
          связь на момент вывода проверенных элементов, иначе они исказятся. </P>
        <p> Окончательно структурная
          схема экономичного кодера выглядит так. </P>
        <p><img src="images/Image301.gif" width="573" height="185"></P>
        <p> - На первом такте Кл.1
          и Кл.3 замкнуты, информационные элементы проходят на выход кодера и
          одновременно формируются проверочные элементы. </P>
        <p> - После того, как в линию
          уйдет пятый информационный элемент, в устройстве деления сформируются
          проверочные; </P>
        <p> - на шестом такте ключи
          1 и 3 размыкаются (разрываются обратная связь), а ключ 2 замыкается
          и в линию уходят проверочные разряды. </P>
        <p> Ячейки при этом заполняются
          нулями и схема возвращается в исходное состояние. </P>
        <P> <b><u>Определение ошибочного
          разряда в ЦК.</u></b> </P>
        <p> Пусть А(х)-многочлен соответствующий
          переданной кодовой комбинации. </P>
        <p> Н(х)- многочлен соответствующей
          принятой кодовой комбинацией.  </P>
        <p> Тогда сложение данных многочленов
          по модулю два даст многочлен ошибки.  </P>
        <P ALIGN="CENTER"> <b>E(x)=A(x) &#197; H(x)</b> </P>
        <p> При однократной ошибке
          Е(х) будет содержать только один единственный член соответствующий ошибочному
          разряду. </P>
        <p> Остаток – полученный от 
          деления принятого многочлена H(x) на производящей P<SUB>r</SUB>(x) равен 
          остатку полученному при делении соответствующего многочлена ошибок E(x) 
          на P<SUB>r</SUB>(x) </P>
        <P> <IMG SRC="images/Image302.gif" WIDTH=102 HEIGHT=46> </P>
        <p> При этом ошибке в каждом
          разряде будет соответствовать свой остаток R(x) (он же синдром), а значит,
          получив синдром можно однозначно определить место ошибочного разряда. </P>
        <P> <b><u>Алгоритм определения 
          ошибки.</u></b> </P>
        <p> Пусть имеем n-элементные 
          комбинации (n = k + r) тогда: </P>
        <p> 1. Получаем остаток от
          деления Е(х) соответствующего ошибке в старшем разряде [1000000000],
          на образующей поленом P<SUB>r</SUB>(x) </P>
        <P> <IMG SRC="images/Image303.gif" WIDTH=114 HEIGHT=52> </P>
        <p> 2. Делим полученный полином
          Н(х) на P<SUB>r</SUB>(x) и получаем текущий остаток R(x). </P>
        <p> 3. Сравниваем R<SUB>0</SUB>(x)
          и R(x). </P>
        <p> - Если они равны, то ошибка
          произошла в старшем разряде. </P>
        <p> - Если "нет", то увеличиваем
          степень принятого полинома на Х и снова проводим деления </P>
        <p> <IMG SRC="images/Image304.gif" WIDTH=130 HEIGHT=52> </P>
        <p> в) Опять сравниваем полученный
          остаток с R<SUB>0</SUB>(x) </P>
        <p> - Если они равны, то ошибки
          во втором разряде. </P>
        <p> - Если нет, то умножаем
          Н(х)х<SUP>2</SUP> и повторяем эти операции до тех пор, пока R(X) не
          будет равен R<SUB>0</SUB>(x). </P>
        <p> Ошибка будет в разряде
          соответствующем числу на которое повышена степень Н(х) плюс один. </P>
        <p> <B>Например:</b> <IMG SRC="images/Image305.gif" WIDTH=132 HEIGHT=56 align="absmiddle">
          то номер ошибочного разряда 3+1=4 </P>
        <P> <b><u>Пример декодирования
          комбинации ЦК.</u></b> </P>
        <p> Положим, получена комбинация 
          H(х)=111011010 </P>
        <p> Проанализируем её в соответствии
          с вышеприведенным алгоритмом. </P>
        <p> Реализуя алгоритм определения 
          ошибок, определим остаток от деления вектора соответствующего ошибке 
          в старшем разряде Х<SUP>8</SUP> на производяший полином P(x)=X<SUP>4</SUP>+X+1 </P>
        <p> X<SUP>8</SUP> <U>X<SUP>2</SUP>+X+1</u> </P>
        <p>  <U>X<SUP>8</SUP>+X<SUP>5</SUP>+X<SUP>4</SUP></u>
          x<SUP>4</SUP>+x+1 </P>
        <p> X<SUP>5</SUP>+X<SUP>4</sup> </P>
        <p> <u>X<SUP>5</SUP>+X<SUP>2</SUP>+X</u> </P>
        <p> X<SUP>4</SUP>+X<SUP>2</SUP>+X </P>
        <p> <u>X<SUP>4</SUP>+X+1</u> </P>
        <p>  X<SUP>2</SUP>+1=R<SUB>0</SUB>(X)=0101 </P>
        <p> Разделим принятую комбинацию 
          на образующий полином </P>
        <p><FONT FACE="Arial" SIZE=3 COLOR="#0000ff">H(x)</font> <FONT FACE="Arial" SIZE=3>
          &#183;</font>  <FONT FACE="Arial" SIZE=3 COLOR="#ff0000">x </font></P>
        <p> <b>111011010 0 
          <U>10011</u></b> </P>
        <p>  <b><U>10011</U> 111111</b> </P>
        <p> <b>5-т 11101</b> </P>
        <p>  <b><U>10011</u></b> </P>
        <p> <b>6-т 11100</b> </P>
        <p>  <b><U>10011</u></b> </P>
        <p> <b>7-т 11111</b> </P>
        <p>  <b><U>10011</u></b> </P>
        <p> <b>8-т 11000</b> </P>
        <p>  <b><U>10011</u></b> </P>
        <p> <b>9-т 10110  
          = R(X) <img src="images/Image00.gif" width="15" height="15">R<SUB>0</SUB>(X)</b> </P>
        <p>  <b><U>10011 </u></b> </P>
        <p><b>10-т
          0101=R<SUB>0</SUB>(x)</b> </P>
        <p> Полученный на 9-м такте
          остаток, как видим, не равен R<SUB>0</SUB>(X). Значит необходимо умножить
          принятую комбинацию на Х и повторить деление. Однако результаты деления
          с 5 по 9 такты включительно будут такими же, значит необходимо продолжить
          деление после девятого такта до тех пор, пока в остатке не будет R<SUB>0</SUB>(Х).
          В нашем случае это произойдет на 10 такте, при повышении степени на
          1. Значит ошибки во втором разряде. </P>
        <P> <b><u>Декодер циклического
          кода с исправлением ошибки</u></b> </P>
        <P><img src="images/Image298.gif" width="567" height="290"></P>
        <P> Если ошибка в первом разряде, то остаток
          R<SUB>0</SUB>(X)=10101 появления после девятого такта в ячейках ФПГ. </P>
        <p> Если во втором по старшинству
          то после 10<SUP>го</SUP>;  </P>
        <p> в третьем по старшинству
          то после 11<SUP>го</SUP>; </P>
        <p> в четвертом по старшинству
          то после 12<SUP>го</SUP>  </P>
        <p> в пятом по старшинству
          то после 13<SUP>го</SUP>  </P>
        <p> в шестом по старшинству
          то после 14<SUP>го</SUP>  </P>
        <p> в седьмом по старшинству
          то после 15<SUP>го</SUP>  </P>
        <p> в восьмом по старшинству
          то после 16<SUP>го</SUP>  </P>
        <p> в девятом по старшинству
          то после 17<SUP>го</SUP>. </P>
        <p> На 10 такте старший разряд
          покидает регистр задержки и проходит через сумматор по модулю 2. </P>
        <p> Если и этому моменту остаток
          в ФПГ=R<SUB>0</SUB>(X), то логическая 1 с выхода дешифратора поступит
          на второй вход сумматора и старший разряд инвертируется. </P>
        <p> В нашем случае инвертируется
          второй разряд на 11 такте.  </P>  <P></P>
        <a name=3 class="anchor"></a><h3>9.3 
          Выбор образующего полинома</h3>
      
        <p> Рассмотрим вопрос выбора
          образующего полинома, который определяет корректирующие свойства циклического
          кода. В теории циклических кодов показано, что образующий полином представляет
          собой произведение так называемых минимальных многочленов <I>m<SUB>i</SUB>(x)</I>,
          являющихся простыми сомножителями (то есть делящимся без остатка лишь
          на себя и на 1) бинома <I>x<SUP>n</SUP>+ </I>1: </P>
        <p> <I>P(x)=m<SUB>1</SUB>(x)*
          m<SUB>3</SUB>(x)…m<SUB>j</SUB>(x)</i>,&#9;&#9;&#9;&#9;&#9;(*) </P>
        <p> где <I>j = d<SUB>0</SUB>
          – </I>2<I> =</I>( 2<I>t<SUB>u.</sub></I><SUB>ош</SUB>+1) – 2 = 2 <I>t</I><SUB>и.ош</SUB>
          – 1. </P>
        <p> Существуют специальные
          таблицы минимальных многочленов, одна из которых приведена ниже. Кроме
          образующего полинома необходимо найти и количество проверочных разрядов
          <I>r</I>. Оно определяется из следующего свойства циклических кодов:
           </P>
        <p> для любых значений <I>l
          </I>и <I>t</I><SUB>и.ош</SUB> существует циклический код длины <I>n
          =</I>2<I><SUP>l</sup></I> – 1, исправляющий все ошибки кратности <I>t</I><SUB>и.ош</SUB>
          и менее, и содержащий не более <IMG SRC="images/Image306.gif" WIDTH=89 HEIGHT=33 align="absmiddle">
          проверочных элементов.  </P>
        <p> Так как <IMG SRC="images/Image307.gif" WIDTH=85 HEIGHT=62 align="absmiddle">,
          то <I><IMG SRC="images/Image308.gif" WIDTH=126 HEIGHT=57 align="absmiddle"></I> откуда <IMG SRC="images/Image309.gif" WIDTH=160 HEIGHT=33 align="absmiddle">.&#9;(**) </P>
        <p></P>
        <p> Очевидно, что для уменьшения
          времени передачи кодовых комбинаций, <I>r</I> следует выбирать как можно
          меньше. Пусть, например, длина кодовых комбинаций <I>n =</I> 7, кратность
          исправляемых ошибок <I>t</I><SUB>и.ош</SUB> =1. Из (**) получим <I>r
          = 1<SUP> .</SUP> log<SUB>2</SUB> ( 7+1 )=3</I>. </P>
        <p> После определения количества
          проверочных разрядов <I>r</I>, вычисления образующего полинома удобно
          осуществить, пользуясь таблицей минимальных многочленов, представленной
          в следующем виде: </P>
        <P> Таблица минимальных многочленов </P>
        <TABLE BORDER CELLSPACING=0 CELLPADDING=0 WIDTH=543>
          <TR>
            <TD WIDTH="10%" VALIGN="TOP" ROWSPAN=2 HEIGHT=18> <p></P>
              <p><I>J=2t</i><SUB>и.ош
                </SUB><I>-1</I> </TD>
            <TD VALIGN="TOP" COLSPAN=6 HEIGHT=18> <P ALIGN="CENTER"> Вид
                минимальных многочленов для </TD>
          </TR>
          <TR>
            <TD WIDTH="16%" VALIGN="TOP" HEIGHT=59> <p> <IMG SRC="images/Image310.gif" WIDTH=70 HEIGHT=52> </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=59> <p> <IMG SRC="images/Image311.gif" WIDTH=73 HEIGHT=54> </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=59> <p> <IMG SRC="images/Image312.gif" WIDTH=70 HEIGHT=52> </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=59> <p> <IMG SRC="images/Image313.gif" WIDTH=73 HEIGHT=54> </TD>
            <TD WIDTH="15%" VALIGN="TOP" HEIGHT=59> <p> <IMG SRC="images/Image314.gif" WIDTH=74 HEIGHT=54> </TD>
            <TD WIDTH="17%" VALIGN="TOP" HEIGHT=59> <p> <IMG SRC="images/Image315.gif" WIDTH=73 HEIGHT=54> </TD>
          </TR>
          <TR>
            <TD WIDTH="10%" VALIGN="TOP" HEIGHT=15> <p> 1 </TD>
            <TD WIDTH="16%" VALIGN="TOP" HEIGHT=15> <p> 2 </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=15> <p> 3 </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=15> <p> 4 </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=15> <p> 5 </TD>
            <TD WIDTH="15%" VALIGN="TOP" HEIGHT=15> <p> 6 </TD>
            <TD WIDTH="17%" VALIGN="TOP" HEIGHT=15> <p> 7 </TD>
          </TR>
          <TR>
            <TD WIDTH="10%" VALIGN="TOP" HEIGHT=18> <p> 1 </TD>
            <TD WIDTH="16%" VALIGN="TOP" HEIGHT=18> <p> <i>x<SUP>2</SUP>+x+1</i> </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=18> <p> <i>x<SUP>3</SUP>+x+1</i> </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=18> <p> <i>x<SUP>4</SUP>+x+1</i> </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=18> <p> <i>x<SUP>5</SUP>+x+1</i> </TD>
            <TD WIDTH="15%" VALIGN="TOP" HEIGHT=18> <p> <i>x<SUP>6</SUP>+x+1</i> </TD>
            <TD WIDTH="17%" VALIGN="TOP" HEIGHT=18> <p> <i>x<SUP>7</SUP>+x+1</i> </TD>
          </TR>
          <TR>
            <TD WIDTH="10%" VALIGN="TOP" HEIGHT=18> <p> 3 </TD>
            <TD WIDTH="16%" VALIGN="TOP" HEIGHT=18> <p> - </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=18> <p> - </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=18> <p> <i>x<SUP>4</SUP>+x<SUP>3</SUP>+<br>
                </i>  <i>+x<SUP>2</SUP>+x+1</i> </P>
              </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=18> <p> <i>x<SUP>5</SUP>+x<SUP>4</SUP>+<br>
                </i>  <i>+x<SUP>3</SUP>+x<SUP>2</SUP>+1</i> </P>
              </TD>
            <TD WIDTH="15%" VALIGN="TOP" HEIGHT=18> <p> <i>x<SUP>6</SUP>+x<SUP>4</SUP>+<br>
                </i>  <i>+x<SUP>2</SUP>+x+1</i> </P>
              </TD>
            <TD WIDTH="17%" VALIGN="TOP" HEIGHT=18> <p> <i>x<SUP>7</SUP>+x<SUP>3</SUP>+<br>
                </i>  <i>+x<SUP>2</SUP>+x+1</i> </P>
              </TD>
          </TR>
          <TR>
            <TD WIDTH="10%" VALIGN="TOP" HEIGHT=18> <p> 5 </TD>
            <TD WIDTH="16%" VALIGN="TOP" HEIGHT=18> <p> - </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=18> <p> - </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=18> <p> - </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=18> <p> <i>x<SUP>5</SUP>+x<SUP>4</SUP>+<br>
                </i>  <i>+x<SUP>2</SUP>+x+1</i> </P>
              </TD>
            <TD WIDTH="15%" VALIGN="TOP" HEIGHT=18> <p> <i>x<SUP>6</SUP>+x<SUP>5</SUP>+<br>
                </i>  <i>+x<SUP>2</SUP>+x+1</i> </P>
              </TD>
            <TD WIDTH="17%" VALIGN="TOP" HEIGHT=18> <p> <i>x<SUP>7</SUP>+x<SUP>4</SUP>+<br>
                </i>  <i>+x<SUP>3</SUP>+x<SUP>2</SUP>+1</i> </P>
              </TD>
          </TR>
          <TR>
            <TD WIDTH="10%" VALIGN="TOP" HEIGHT=18> <p> 7 </TD>
            <TD WIDTH="16%" VALIGN="TOP" HEIGHT=18> <p> - </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=18> <p> - </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=18> <p> - </TD>
            <TD WIDTH="14%" VALIGN="TOP" HEIGHT=18> <p> - </TD>
            <TD WIDTH="15%" VALIGN="TOP" HEIGHT=18> <p> <i>x<SUP>6</SUP>+x<SUP>3</SUP>+1</i> </TD>
            <TD WIDTH="17%" VALIGN="TOP" HEIGHT=18> <p> <i>X<SUP>7</SUP>+x<SUP>6</SUP>+x<SUP>5</SUP>+<br>
                </i>  <i>+x<SUP>4</SUP>+x<SUP>2</SUP>+x+1</i> </P>
              </TD>
          </TR>
        </TABLE>
        <p></P>
        <p> Определяя образующий полином,
          нужно из столбца для соответствующего соотношения <IMG SRC="images/Image316.gif" WIDTH=41 HEIGHT=52 align="absmiddle">
          выписать все многочлены, начиная с верхней строки до нижней с номером
          <I>j=2t</I><SUB>и.ош</SUB>–<I>1</I> включительно. После этого следует
          перемножить выбранные минимальные многочлены в соответствии с (*). В
          частности, если <I>r=3</I>, <I>t</I><SUB>и.ош</SUB><I>=1</I>, <I>j=2*1-1=1</I>,
          образующий полином будет представлять собой единственный минимальный
          многочлен <I>P(x)= m<SUB>1</SUB>(x) = x<SUP>3</SUP>+x+1</I> (первая
          строка, второй столбец таблицы ). Соответственно образующее число равно
          1011.  </P>
        <p> Контрольные вопросы по 
          теме: </P>
        <OL>
          <LI> Что такое разрешенные и запрещенные 
            кодовые комбинации. </LI>
          <LI> Что называется расстоянием Хемминга. </LI>
          <LI> Дайте понятие кодового расстояния и 
            как его определить. </LI>
          <LI> Как связано кодовое расстояние с исправляющей 
            и обнаруживающей способностью кода. </LI>
          <LI> Какой код называется линейным. </LI>
          <LI> Какое множество называется группой. </LI>
          <LI> Назовите основные свойства циклических 
            кодов. </LI>
          <LI> Запишите полином <IMG SRC="images/Image317.gif" WIDTH=82 HEIGHT=20> 
            в двоичном виде. </LI>
          <LI> Запишите полином, соответствующий двоичной 
            записи 100111. </LI>
          <LI> Получите остаток от деления полинома 
            <IMG SRC="images/Image318.gif" WIDTH=98 HEIGHT=20> на <IMG SRC="images/Image319.gif" WIDTH=76 HEIGHT=20>. </LI>
          <LI> Как получают разрешенные комбинации 
            при циклическом кодировании. </LI>
          <LI> Нарисуйте кодер для циклического кода, 
            порождаемого полиномом <IMG SRC="images/Image320.gif" WIDTH=76 HEIGHT=20>. 
            Поясните принцип работы кодера. </LI>
          <LI> По какому признаку обнаруживают ошибку 
            в принятой кодовой комбинации. </LI>
          <LI> Каков алгоритм определения ошибочного 
            разряда в комбинации циклического кода. </LI>
          <LI> Нарисуйте структурную схему декодера, 
            обеспечивающего обнаружение ошибок для кода (7,4) при производящем 
            полиноме <IMG SRC="images/Image320.gif" WIDTH=76 HEIGHT=20>. Поясните 
            принцип его работы. </LI>
          <LI> Нарисуйте структурную схему декодера, 
            обеспечивающего исправление однократной ошибки для кода (7,4) при 
            производящем полиноме <IMG SRC="images/Image320.gif" WIDTH=76 HEIGHT=20>. 
            Поясните принцип его работы. </LI>
          <LI> Как выбирается образующий (производящий) 
            полином? </LI>
        </OL>
<br><br>
<!--конец-->
      
				

				</div>
			</div>
			
      </div>
    </div>
  </div>
	
	<!--Меню навигации по Темам -->	
	<div aria-label="..." class = "nav-menu">
	 <ul class="pager background-transition-slow">
		 <li title="Наверх" style = "margin-right:15px;	"><a class = "glyphicon glyphicon-menu-up page-scroll" href="#page-top"></a></li>
		 <li title="К предыдущей лекции"><a class = "glyphicon glyphicon-menu-left page-scroll" href="t8.htm"></a></li>
		 <li title="В содержание"><a class = "glyphicon glyphicon-list-alt" href="lec_index.htm"></a></li>
		 <li title="К следующей лекции"><a class = "glyphicon glyphicon-menu-right page-scroll" href="t10.htm"></a></li>
	 </ul>
	</div>
	<!---->
	
	</div>
  <!-- jQuery -->
  <script src="../lib/js/jquery.js"></script>

  <!-- Bootstrap Core JavaScript -->
  <script src="../lib/js/bootstrap.min.js"></script>

  <!-- Scrolling Nav JavaScript -->
  <script src="../lib/js/jquery.easing.min.js"></script>
  <script src="../lib/js/scrolling-nav.js"></script>

</body>

</html>
